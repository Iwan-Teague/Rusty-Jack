RUSTYJACK SECURITY REVIEW (code-level, Rust-focused)
Target platform: Raspberry Pi Zero 2 W, Raspbian 32-bit (Trixie CLI)
Review date: 2026-01-02 (Europe/Dublin)
Scope: repository contents in Rustyjack.zip, with deep focus on rustyjack-daemon (rustyjackd)
====================================================================================================

0) Executive summary
- The overall architecture (privileged daemon over Unix Domain Socket + unprivileged clients) is the right idea.
- The current daemon implementation is close, but there are a few security-relevant boundary leaks and reliability hazards.
- The biggest security issue today is that the generic JobStart endpoint can bypass the validation performed by the
  specialized *Start endpoints* (WifiConnectStart/PortalStart/MountStart/etc). If a client uses JobStart directly,
  they can pass parameters that the dedicated endpoints would reject (e.g., privileged ports, unsafe device paths,
  risky update remotes/branches). This undermines the daemon boundary.
- The second major class of issues is observability and robustness: the daemon runs on a single-thread tokio runtime,
  but performs multiple blocking operations directly (std::process::Command and lots of filesystem reads). One slow
  request can stall the whole daemon, and large responses (system logs) can exceed the IPC frame limit and fail.
- There is also a mismatch between the “real” Wi‑Fi/attack logic living in rustyjack-core/operations.rs and the daemon
  currently calling placeholder implementations in rustyjack-core/services/wifi.rs. This isn’t a vulnerability per se,
  but it indicates that privileged functionality is still outside the daemon boundary (core CLI), and the daemon path
  may not be the one you actually use.

High-level recommended priorities:
  P0 (must fix before relying on daemon boundary):
    - Validate JobStart per JobKind (same rules as specialized endpoints). Also enforce per-job authz tiers.
    - Lock down mount/unmount requests: prevent arbitrary umount targets; prevent mounting internal mmc partitions.
    - Put size limits/streaming on SystemLogsGet (and any large response) so it cannot exceed max_frame.
    - Move blocking work off the single-thread runtime (spawn_blocking or multi_thread runtime).
  P1:
    - Make job cancellation real (abort blocking tasks / propagate CancellationToken).
    - Fix job retention so running jobs are never evicted.
    - Improve structured logging + error mapping so failures are diagnosable.
  P2:
    - Consolidate “privileged operations” into daemon-only crates/features; avoid installing the core CLI on production images.
    - Consider systemd hardening/capability bounding so the daemon runs with minimum privileges required.

====================================================================================================

1) What’s in the repo (relevant pieces)
Workspace contains multiple crates; the key ones for the privileged boundary:
  - rustyjack-daemon: privileged UDS daemon (rustyjackd)
  - rustyjack-ipc: protocol types + framing + error codes
  - rustyjack-client: UDS client used by UI
  - rustyjack-ui: unprivileged UI that talks to daemon
  - rustyjack-core: big library + CLI binary with many low-level networking/attack operations
  - rustyjack-netlink / rustyjack-wireless / rustyjack-portal: low-level netlink/raw socket + portal server

Important architectural observation:
  rustyjack-core has a full CLI binary (rustyjack-core/src/main.rs) and a very large operations surface (operations.rs)
  that performs privileged actions directly. If that binary is installed or callable on-device, the daemon boundary is
  not the only way to perform privileged actions.

====================================================================================================

2) Threat model assumptions (based on your description)
Given: dedicated Pi with Rustyjack as the only “purpose”; daemon may run as root and perform privileged actions.
Reasonable attacker models to design for anyway:
  A) Local unprivileged user (or compromised UI process) who can access the UDS (via group permissions).
     Goal: escalate to root or cause persistence/brick.
  B) Remote network attacker who can reach Rustyjack’s exposed services (e.g., captive portal) and exploit them.
     Goal: code execution in daemon process or on-device.
  C) Malicious removable media (USB storage) providing weird filesystem metadata or timing behavior.

The daemon boundary mainly protects against (A). Hardening the portal and other network-facing code helps against (B).

====================================================================================================

3) Daemon deep dive (rustyjack-daemon)

3.1 IPC, framing, handshake, and peer credentials
Files:
  - rustyjack-daemon/src/server.rs
  - rustyjack-daemon/src/auth.rs
  - rustyjack-ipc/src/wire.rs

What’s good:
  - Length-prefixed framing with max_frame enforcement protects against large allocation DoS.
  - The daemon uses SO_PEERCRED to log peer pid/uid/gid on accept.
  - RequestEnvelope includes request_id and endpoint; the daemon checks endpoint == endpoint_for_body.

Gaps / risks:
  - No read/write timeouts on the UDS. A client can connect and stall reads/writes indefinitely.
  - Server uses a single-thread tokio runtime (current_thread). Any blocking work in the request path will stall the entire daemon.

Implementation guidance:
  - Add timeouts around read_frame and write_frame (tokio::time::timeout).
  - Either switch to a multi_thread runtime or ensure *every* blocking syscall/command execution is isolated in spawn_blocking.


3.2 Authorization model and socket permissions
Files:
  - rustyjack-daemon/src/systemd.rs (socket binding + chmod/chown)
  - rustyjack-daemon/src/auth.rs (tier mapping)

Current behavior:
  - Socket is created with mode 0660; group optionally set via RUSTYJACKD_SOCKET_GROUP.
  - Authorization tier is derived solely from uid: uid==0 => Admin, else Operator.

Security implications:
  - If you grant a non-root user access to the socket via group membership, they become “Operator” and can call all Operator endpoints.
  - That’s fine if Operator endpoints are genuinely safe for that trust level; currently, some Operator endpoints are high-impact.

Implementation guidance:
  - Keep the filesystem permission boundary as the primary gate (it’s the right tool for UDS).
  - Add per-endpoint/per-job authorization checks that reflect risk. Example: updates and reboot/shutdown should be Admin-only.
  - Consider mapping tiers by *gid* as well (e.g., only members of a specific admin group can do Update), not just uid==0.


3.3 The biggest boundary leak: JobStart bypasses validation
Files:
  - rustyjack-daemon/src/dispatch.rs (RequestBody::JobStart)
  - rustyjack-daemon/src/validation.rs (validation functions)
  - rustyjack-ipc/src/job.rs (JobKind payloads)

Problem:
  The daemon has specialized endpoints that validate input before creating a job:
    - WifiScanStart validates interface + timeout
    - WifiConnectStart validates interface + ssid + psk + timeout
    - PortalStart validates interface + port
    - MountStart/UnmountStart validate device + filesystem
  BUT the generic JobStart endpoint starts jobs directly from JobSpec without validating the embedded request.
  That means a client can send JobStart with JobKind::PortalStart{port: 80} and bypass validate_port (which rejects <1024).
  Same pattern applies to MountStart/UnmountStart, WifiConnect, and especially SystemUpdate (remote/branch/service strings).

Impact:
  - The validation you wrote is not actually enforcing safety unless you can guarantee clients never call JobStart.
  - If the UI or any other local client is compromised, it can supply parameters that are explicitly forbidden by the safer endpoints.

Best implementation fix (recommended): centralize validation for *all* job launches
  Option A (minimal invasive):
    - In dispatch.rs under RequestBody::JobStart, call a new function validate_job_kind(&JobKind) -> Result<(), DaemonError>
      that applies the same rules as the specialized endpoints.
    - Then (and only then) call state.jobs.start_job.
  Option B (cleaner design):
    - Remove specialized endpoints entirely, and only expose JobStart with strict validation.
    - The “start endpoints” become thin client-side conveniences.

Concrete checklist for validate_job_kind:
  - Sleep: seconds <= some sane limit (to prevent retention abuse)
  - ScanRun: validate target length, timeout bounds, ports list size & range
  - WifiScan/WifiConnect/HotspotStart/PortalStart: reuse validate_iface_name/ssid/psk/port/channel
  - MountStart/UnmountStart: validate and *resolve* to an allowed mount target (see mount section below)
  - SystemUpdate: validate service/remote/branch with allowlists (see update section below)


3.4 Per-job authorization is missing (update is the scary example)
Files:
  - rustyjack-daemon/src/auth.rs (required_tier)
  - rustyjack-daemon/src/dispatch.rs (JobStart and Update job path)
  - rustyjack-core/src/operations.rs + src/system.rs (update implementation)

Problem:
  Endpoint::JobStart is Operator-tier. That means an Operator can start *any* job kind that isn’t blocked by dangerous_ops.
  If/when you enable updates (RUSTYJACK_ALLOW_UNSAFE_UPDATES=1 in the daemon env), an Operator can:
    - pull arbitrary code (remote/branch are user-provided)
    - build it (cargo build)
    - restart a systemd service
  This is effectively a root code execution path for any client with socket access.

Implementation guidance:
  - Add required_tier_for_jobkind(kind) and enforce it in both JobStart and the specialized endpoints.
  - Strong recommendation: SystemUpdate should be Admin-only.
  - Consider making MountStart/UnmountStart Operator-only but constrained to removable media under a fixed mount root.


3.5 Mount/Unmount: current daemon path is weaker than your existing Rust mount module
Files:
  - rustyjack-daemon/src/dispatch.rs (MountStart/UnmountStart validation)
  - rustyjack-core/src/services/mount.rs (daemon currently calls this)
  - rustyjack-core/src/mount.rs (much stronger mount policy + syscalls)

Findings:
  A) Unmount validation is dangerously permissive
     - dispatch.rs uses validate_device_path for UnmountStart.
     - validate_device_path only checks "absolute path" and forbids "..".
     - But `umount` accepts either a mountpoint or a device path. So a malicious client could try to unmount arbitrary
       mountpoints (e.g., /boot, /home, etc) by passing those absolute paths.

  B) MountStart can mount internal storage partitions
     - services/mount.rs mounts any /dev/* device; it does not enforce "removable USB only".
     - list_block_devices filters out mmcblk internally, but mount_device does not. So a client could request /dev/mmcblk0p1.

  C) You already have a better implementation in rustyjack-core/src/mount.rs
     - That module does: canonical_device_path, block-device checks, USB-removable checks via sysfs, allowed FS allowlist,
       mount root confinement, mount locking, and uses libc::mount/umount2 instead of spawning mount/umount.

Best implementation approach:
  - Replace daemon’s mount implementation to use rustyjack_core::mount::{MountPolicy, mount_device, unmount_device, list_*}.
  - Define a single mount_root (e.g., /media/rustyjack or /mnt/rustyjack) and enforce that all mounts live under it.
  - Change the IPC so that unmount identifies mounts by an ID returned from MountList (or by mountpoint under mount_root),
    not by arbitrary string paths.

Concrete changes:
  - Add a daemon-side MountPolicy (configurable by env) and pass it into mount operations.
  - In validate_job_kind / validate_mount_request:
      * require device starts with /dev/
      * reject mmcblk* and other known internal devices
      * verify it is a block device and removable USB
      * limit filesystem to allowlist (vfat/ext4/exfat) or detect automatically
  - For unmount:
      * accept only mountpoints under mount_root OR accept job args that refer to a known mount from list_mounts.


3.6 SystemLogsGet can exceed IPC max_frame and fail (DoS / debuggability issue)
Files:
  - rustyjack-core/src/services/logs.rs (collect_log_bundle)
  - rustyjack-daemon/src/server.rs (write_frame enforces max_frame)

Problem:
  collect_log_bundle can generate very large text (journalctl, dmesg, etc). The daemon then serializes it into a single
  IPC response. If the response exceeds max_frame (default 1,048,576 bytes), write_frame returns an error and the daemon
  logs "Failed to write response". The client gets nothing useful.

Impact:
  - You cannot rely on SystemLogsGet during real failures because the output may be huge exactly when you need it.
  - A client can also intentionally request logs repeatedly and force repeated failures/spam.

Best implementation options:
  Option A (quick win): Truncate + annotate
    - Hard-cap log bundle size (e.g., 256KB) and append "(truncated)".
  Option B (better): Chunked/streamed log download
    - Add endpoints: SystemLogsStart -> returns handle/id; SystemLogsChunk{offset, max_bytes} -> returns bytes;
      SystemLogsDone.
  Option C (best for embedded): Write a compressed bundle to disk and return the path + size
    - Daemon writes /var/lib/rustyjack/logs/<ts>.tar.zst with permissions 0600; client can request download in chunks.

Also recommended:
  - Add timeouts to each subprocess call used to collect logs.


3.7 Blocking operations on a single-thread runtime
Files:
  - rustyjack-daemon/src/main.rs (tokio::main flavor=current_thread)
  - rustyjack-daemon/src/dispatch.rs (calls into core services)
  - rustyjack-core/src/services/mount.rs and services/logs.rs (std::process::Command and filesystem reads)

Finding:
  Several daemon request handlers call functions that execute external commands and do heavy I/O without spawn_blocking.
  Example: BlockDevicesList calls list_block_devices() which runs `lsblk`; SystemLogsGet runs multiple subprocesses.
  On a current_thread runtime, that blocks all connections, job polling, watchdog, etc.

Best implementation:
  - Wrap all std::process::Command usage (and heavy filesystem traversal) in tokio::task::spawn_blocking.
  - Alternatively switch to multi_thread runtime; on Pi Zero 2 W you still benefit because spawn_blocking gets its own pool.
  - For truly long operations, prefer the job system so the request returns quickly.


3.8 Job system logic review
Files:
  - rustyjack-daemon/src/jobs/mod.rs
  - rustyjack-daemon/src/jobs/kinds/*.rs
  - rustyjack-daemon/src/locks.rs

Findings:
  A) Cancellation is mostly ineffective for real jobs
     - cancel_job sets a CancellationToken.
     - Most job kinds check cancellation only once at job start, then call spawn_blocking and await completion.
     - Result: cancelling a WiFiConnect/MountStart/Update job usually does not stop the underlying work.

  B) Retention can evict running jobs
     - enforce_retention removes the oldest jobs regardless of state.
     - If the job list exceeds retention while some old jobs are still running, those running jobs can be removed from the map.
       The work continues but status becomes unqueryable.

  C) No per-job concurrency limits besides coarse locks
     - Locks are good, but jobs like ScanRun can still be started repeatedly and consume CPU/RAM.

Implementation guidance:
  - Make cancellation real:
      * Keep the JoinHandle from spawn_blocking and abort it when CancellationToken triggers.
      * Where possible, restructure long work into chunks that check token between steps.
      * For subprocess-based work, send SIGTERM/SIGKILL to the child.
  - Fix retention:
      * Only evict jobs in a terminal state (Completed/Failed/Cancelled).
      * Never evict Running/Queued jobs.
      * Consider separate caps: max_active_jobs and max_history_jobs.
  - Consider per-kind quotas or rate limiting (especially for ScanRun).


3.9 Logging and error diagnosability
Files:
  - rustyjack-daemon/src/telemetry.rs
  - rustyjack-daemon/src/server.rs
  - rustyjack-ipc/src/error.rs

Current state:
  - Basic env_logger logging.
  - log_request logs request_id + endpoint + Ok/Err (but not duration, peer identity, or structured fields).
  - Many error mappings collapse into ErrorCode::Internal, losing useful categorization.

What you want for debugging (especially on a headless Pi):
  - Every request log should include: timestamp, request_id, endpoint, peer uid/gid/pid, auth tier, duration_ms.
  - Every job log should include: job_id, kind, requested_by, start/finish times, final state, error code.
  - Errors should carry safe detail strings and a stable error code (MountFailed/WifiFailed/UpdateFailed/etc).

Best implementation:
  - Switch to `tracing` + `tracing_subscriber` and emit JSON logs (journald loves this).
  - Create a per-connection span (peer creds) and per-request span (request_id, endpoint).
  - Improve error mapping:
      * Mount-related failures => ErrorCode::MountFailed
      * WiFi-related failures => ErrorCode::WifiFailed
      * Update-related failures => ErrorCode::UpdateFailed
      * IO errors => ErrorCode::Io
  - Populate DaemonError.source with a stable string (e.g., "daemon.dispatch.mount_start" or "core.mount.mount_device").
  - Be careful to redact secrets: never log WiFi PSKs, captured portal credentials, etc.


3.10 Startup reconciliation (crash recovery)
Files:
  - rustyjack-daemon/src/state.rs (reconcile_on_startup)

Finding:
  reconcile_on_startup currently only logs the mount count.
  On an embedded appliance, daemon restarts are normal; you want deterministic recovery.

Recommended reconciliation actions:
  - Mounts: list mounts under mount_root and ensure they match daemon’s expected policy; optionally unmount stale mounts.
  - Portal: ensure no leftover iptables/nftables rules; ensure portal not listening.
  - Hotspot: ensure hostapd/dhcp state is consistent; tear down partial setup.
  - Locks/jobs: mark all jobs as Cancelled on startup; clear lock states.


3.11 Unimplemented / effectively-uncallable operations (and why to care)
Files:
  - rustyjack-daemon/src/dispatch.rs (CoreDispatch handling)
  - rustyjack-daemon/src/server.rs (HelloAck.features is always empty)
  - rustyjack-ipc/src/types.rs (feature flags include JobSubscribe/Compression but not actually used)

Findings:
  - CoreDispatch is present in the protocol, but the daemon currently returns NotImplemented even if allow_core_dispatch is set.
    This is good from a security standpoint (it avoids exposing the huge core CLI surface through the daemon), but it can be
    confusing during development because the knob exists but doesn’t unlock anything.
  - Feature negotiation isn’t wired up yet: HelloAck.features is always an empty Vec, so clients cannot discover whether
    optional behaviors like job streaming/chunked responses exist.
  - Several "real" capabilities (notably Wi‑Fi operations) appear to exist only in the core CLI path today (operations.rs),
    while the daemon-facing service layer is still a stub. This can lead to a dangerous situation later where you "turn on"
    daemon Wi‑Fi by copying code quickly without bringing over the guardrails (validation, logging, cancellation).

Implementation guidance:
  - Either remove CoreDispatch entirely (preferred), or implement it only for a tiny allowlisted set of commands with strict validation.
  - Make feature flags real: advertise DangerousOps, JobSubscribe, Compression (if implemented) so clients can adapt safely.
  - When migrating real functionality into the daemon path, treat it as a new attack surface: add validation, timeouts, and logs first.

====================================================================================================

4) Privileged operations that currently bypass the daemon (and why it matters)

4.1 The core CLI binary is a privileged backdoor to the whole system
Files:
  - rustyjack-core/src/main.rs
  - rustyjack-core/src/operations.rs (large)
  - rustyjack-core/src/wireless_native.rs, netlink helpers, etc.

Finding:
  Rustyjack-core includes a standalone CLI that dispatches many privileged operations directly. If it is installed on the
  Pi image (or left accessible), the daemon is not the only privileged control plane.

Security implication:
  - Any local compromise can skip the daemon’s authz and validation entirely by executing the CLI under root (or via sudo).
  - Even if you run everything as root today, it undermines your stated design goal: "the daemon will handle privileged actions".

Recommended implementation approach:
  - Split the crate outputs:
      * Keep rustyjack-core as a library (no installed binary) on production images.
      * Put the CLI binary behind a Cargo feature (e.g., feature = "dev-cli") and disable it in release builds.
  - Alternatively, make the CLI a thin client that talks to the daemon rather than executing operations locally.


4.2 Wi‑Fi logic mismatch: daemon calls placeholder services
Files:
  - rustyjack-core/src/services/wifi.rs (currently placeholder / stubby)
  - rustyjack-core/src/operations.rs (handle_wifi_scan + other real Wi‑Fi/attack logic)
  - rustyjack-daemon/src/jobs/kinds/wifi_scan.rs and wifi_connect.rs (call services/wifi.rs)

Finding:
  The daemon’s Wi‑Fi job kinds call rustyjack_core::services::wifi::{scan, connect, disconnect}, but those service
  functions currently return placeholder values and do not perform real work.

Why this matters for security:
  - It indicates that the “actual” privileged behavior likely still lives outside the daemon boundary (operations.rs).
  - When you migrate the real logic into daemon-callable services, you must ensure that logic is validated, cancellable,
    and properly logged.

Recommended implementation path:
  - Move the real Wi‑Fi operations from operations.rs into rustyjack-core/services/wifi.rs (or a new dedicated crate).
  - Ensure all parameters originate from daemon-validated requests.
  - Make Wi‑Fi operations job-based (they already are) and cancellation-aware.

====================================================================================================

5) Other logic that should move behind the daemon (privileged boundary tightening)
The rule of thumb: if it needs root, CAP_NET_ADMIN, CAP_NET_RAW, CAP_SYS_ADMIN, or touches sensitive files, it should be
daemon-only.

Candidates in this repo:
  - Anything in rustyjack-core/operations.rs that:
      * manipulates interfaces, routes, iptables/nftables, sysctl, rfkill
      * uses raw sockets (packet capture/injection)
      * mounts/unmounts
      * starts/stops services (systemd)
      * writes config files (wpa_supplicant/hostapd/dnsmasq equivalents)
  - Anti-forensics operations (core/anti_forensics.rs) – these are high risk and should be Admin-only jobs if included.
  - Update/build/restart logic – Admin-only jobs.

Implementation guidance:
  - Create a crate boundary like `rustyjack-privileged` used only by daemon.
  - Gate privileged modules behind a Cargo feature that only the daemon enables.
  - Keep UI/client crates dependency-free from low-level netlink/raw socket crates.

====================================================================================================

6) Concrete implementation plan (ordered)

P0 — Fix boundary leaks + make daemon reliable
  1) Add validate_job_kind(&JobKind) and call it from RequestBody::JobStart.
     - Reuse existing validation helpers in rustyjack-daemon/src/validation.rs.
     - Add missing validators: ScanRun, SystemUpdate (service/remote/branch), Job Sleep bounds, etc.
  2) Add required_tier_for_jobkind(&JobKind) and enforce it.
     - Make SystemUpdate Admin-only.
  3) Replace mount service path to use rustyjack-core/src/mount.rs policy-based syscalls.
     - Constrain mounts to removable media under a mount_root.
     - Unmount only within mount_root or by mount id.
  4) Fix SystemLogsGet output size.
     - Implement truncation now; implement chunked/streamed logs later.
  5) Move blocking operations into spawn_blocking.
     - At minimum: BlockDevicesList and SystemLogsGet.


P1 — Job correctness + observability
  6) Implement real cancellation for spawn_blocking tasks.
     - Keep JoinHandle, abort on cancel; for subprocesses kill child.
  7) Fix job retention to never evict active jobs.
  8) Improve logging:
     - Add request duration; include peer creds; include job_id on job logs.
     - Prefer tracing + JSON.
  9) Improve error mapping to use dedicated ErrorCode variants.


P2 — Reduce overall attack surface
  10) Remove/feature-gate the core CLI in production images.
  11) Migrate real Wi‑Fi logic into daemon-callable services and delete the duplicate path.
  12) Consider running portal as a separate unprivileged process (or at least isolate it) because it is network-facing.
  13) Harden systemd unit: CapabilityBoundingSet, NoNewPrivileges, ProtectSystem, ProtectKernel*, PrivateTmp, etc.

====================================================================================================

Appendix A — Specific code locations worth re-checking
  - Daemon JobStart validation gap: rustyjack-daemon/src/dispatch.rs (RequestBody::JobStart)
  - Unmount path validation: rustyjack-daemon/src/validation.rs (validate_device_path) and dispatch.rs (UnmountStart)
  - Mount implementation currently used by daemon: rustyjack-core/src/services/mount.rs
  - Stronger mount module you should use instead: rustyjack-core/src/mount.rs
  - Log bundle generation (size risk): rustyjack-core/src/services/logs.rs (collect_log_bundle)
  - Single-thread runtime: rustyjack-daemon/src/main.rs
  - Job cancellation/retention: rustyjack-daemon/src/jobs/mod.rs
  - Update pipeline risk: rustyjack-core/src/operations.rs (run_system_update_with_progress) and src/system.rs (git_reset_to_remote)

End of report.
