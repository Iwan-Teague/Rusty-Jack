Network-interface selection: end-to-end trace + why it currently “times out & retries”

1) Invariants (engineering constraints)
When a user confirms an interface in Hardware Detect → Hardware Select:

- Previous “active” interface is brought DOWN (admin down) first.
- Selected interface is brought UP (admin up) next.
- Exactly one interface is admin-UP (except explicit hotspot exception scenarios).
- Wireless: must not auto-connect to any network.
- Wired: if carrier/cable present → DHCP + IP + route + DNS; if no carrier → keep admin-UP and still mark it “active”.
- No external command binaries (ip, rfkill, dhclient, nmcli, etc.). Rust-only netlink/rfkill/DHCP.
- Pipeline semantics: each step runs once, then waits for a definitive result (success/failure) before moving on.
  If a step fails, UI shows where and why, and it’s logged.

2) Current workflow (from UI confirmation to “final stage”)

2.1) UI: hardware select confirmation
File: rustyjack-ui/src/app.rs

On confirm, UI calls:
- core.set_active_interface(interface_name)   (daemon IPC; not local system config)

UI also:
- Updates/saves UI config immediately:
  config.settings.active_network_interface = interface_name
- Polls /sys/class/net/<iface>/flags for up to ~15s (“Acquiring DHCP…”) and errors if it doesn’t see IFF_UP.

Mismatch:
- The UI message says “Acquiring DHCP lease…”, but UI is not performing DHCP here.
  It’s only waiting for admin-UP.

Failure modes:
- UI persists “active interface” before the interface is actually usable.
- UI can show a DHCP-themed error even though DHCP was never attempted.

2.2) UI → daemon IPC
File: rustyjack-ui/src/core.rs

Uses rustyjack-client to send:
- SetActiveInterface { interface } over the Unix socket.

2.3) daemon dispatch
File: rustyjack-daemon/src/dispatch.rs

Handles Request::SetActiveInterface and calls:
- rustyjack_core::operations::set_active_interface(...)

Runs in a blocking task (good).

2.4) core operation
File: rustyjack-core/src/operations.rs::set_active_interface

- Persist preference via PreferenceManager
- Construct IsolationEngine(RealNetOps)
- Call engine.enforce_passive()

2.5) IsolationEngine enforcement (the “real work”)
File: rustyjack-core/src/system/isolation.rs

Key points:
- enforce_passive() maps to EnforcementMode::Selection (“admin-UP only”).
  That means: no carrier check, no DHCP, by design.
- The engine:
  1) lists interfaces
  2) selects active = preferred if present
  3) blocks all other interfaces (release DHCP, delete default route, bring down, rfkill-block if wireless)
  4) activates the chosen interface
  5) verifies default route expectations + DNS file sanity

2.6) Where the arbitrary sleeps/retries are today
In activate_interface() (rustyjack-core/src/system/isolation.rs):

- RFKill settle delay: after set_rfkill_block(false), sleeps 100ms
- Admin-UP confirmation: polls /sys/class/net/<iface>/flags up to 20×100ms (2s)
- If not UP: calls bring_up again (retry)
- Then polls another 10×100ms (1s)
- If still not UP: error

In Passive mode wired DHCP (used by enforce()/Connectivity paths, not the hardware-select path right now):
- DHCP loop: 3 attempts, sleeping 5s between attempts

So the project currently mixes:
(a) do operation and (b) sleep/poll/retry in multiple places.

3) Does the UI interact with the daemon correctly?

Mechanically: yes — IPC request/response path is coherent and the daemon executes isolation logic in a blocking task.

Semantically: gaps vs pipeline goals:

1) UI duplicates state verification (polling sysfs) instead of trusting daemon “step results”.
2) UI persists “active interface” too early.
3) UI ignores structured error detail:
   daemon returns SetActiveInterfaceResponse { allowed, blocked, errors }
   UI mostly treats Ok as success and doesn’t surface errors[] as a first-class failure with stage context.
4) Hardware-select flow does not do wired DHCP at all (Selection mode is admin-UP only), yet UI claims it is.
5) NetworkManager “unmanaged” is currently a no-op in RealNetOps:
   - activate_interface() says “set unmanaged BEFORE bring_up to prevent NM interference”
   - but RealNetOps.apply_nm_managed() returns Ok(()) and does not talk to NM
   - if NetworkManager is running, it can violate invariants (auto-connect WiFi, bring up other links, etc.)

4) Proposed redesign: real pipeline with step-level results (Rust-only)

4.1) Move interface selection to a daemon Job with progress + structured failure
You already have a job system (rustyjack-daemon/src/jobs/*, rustyjack-ipc/src/job.rs) with:
- phases (Progress { phase, percent, message })
- structured completion/failure (DaemonError)

Add a new job kind:
- JobKind::InterfaceSelect { interface: String }

UI behavior:
1) user confirms interface
2) UI starts job
3) UI displays live phase/progress
4) on failure: UI shows “Step X failed: reason” (and logs contain full context)

4.2) Make pipeline steps explicit (and log them)
Suggested step breakdown (each step emits progress update; logs in a span with job_id, iface, step):

Step 1: Validate & snapshot
- confirm interface exists
- read interface list + current “active”
- snapshot rfkill status (if wireless) and admin states

Step 2: Deactivate others
- for each non-selected iface:
  - release DHCP
  - flush addresses (InterfaceManager::flush_addresses exists)
  - remove default route(s)
  - set admin DOWN
  - if wireless: rfkill BLOCK
- wait until admin-DOWN observed

Step 3: Prepare selected
- if wireless:
  - rfkill UNBLOCK
  - wait until rfkill soft-block==0 (or fail with hard-block reason)
  - ensure “no auto connect”: either unmanage via NM over D-Bus, or ensure your own WiFi stack isn’t associating here
- set admin UP
- wait until admin-UP observed

Step 4: Wired-only connectivity
- if wired:
  - check carrier
  - if carrier==1: run DHCP acquisition once with a single overall timeout
    (DHCP already retransmits internally; don’t add “3 tries with 5s sleep” on top)
  - if carrier==0: succeed with “no carrier” note; keep admin-UP

Step 5: Invariant verification
- exactly one admin-UP interface (except hotspot exception)
- selected is admin-UP
- wireless is not connected (if observable)
- if DHCP succeeded: IP present + route set + DNS written

Step 6: Persist preference
- only after Step 5 passes

4.3) Replace “retry after sleep” with “wait for the system to report completion”
Keep a safety timeout to avoid hanging forever, but remove repeated “try again N times”.

- Admin up/down waiting: subscribe to RTMGRP_LINK netlink notifications and wait for link flag change event
  (instead of polling /sys/class/net/.../flags with sleeps)
- Carrier waiting: same mechanism (RTM_NEWLINK often carries operstate), or read /sys/class/net/<iface>/carrier
- RFKill waiting: after writing to /dev/rfkill, wait until /sys/class/rfkill/rfkillX/soft reflects desired value
  (fail fast if /hard == 1)

4.4) Fix NetworkManager integration (or explicitly disable it)
Currently apply_nm_managed() is a stub; isolation can be undermined by NM.

Options:
- Implement RealNetOps.apply_nm_managed() via the existing Rust D-Bus client (rustyjack-core/src/system/nm.rs).
- Or: ensure NM is not running in this environment and remove misleading code/comments.

Given “wireless must not auto connect”, you need an authoritative layer preventing auto-association.
If it’s not NM, it must be your own WiFi management or rfkill strategy (but rfkill conflicts with “interface UP”).

5) Sharp edges to flag for senior networking folks

- RFKill device matching is name-based (rfkill device name contains interface string). Can be brittle (rfkill name can be phy0).
- enforce_passive() uses Selection mode, so “wired DHCP on selection” is not met on today’s call path.
- verify_enforcement() checks routing/DNS but does not verify “only one admin-UP interface”. If required, enforce explicitly.
- netlink_watcher looks like it’s iterating “get()” dumps rather than a true multicast subscription; “auto-retry when cable plugged”
  may not trigger reliably.

6) Logging + UI error reporting

Existing logs:
- daemon: /opt/rustyjack/logs/rustyjackd.log
- UI: /opt/rustyjack/logs/rustyjack-ui.log

For the new pipeline job:
- each step runs inside a tracing span with job_id, iface, step
- on failure, return DaemonError with:
  - message: user-facing (“RFKill unblock failed”)
  - detail: technical (“hard blocked=1, soft blocked stays 1 after request”)
  - source: underlying error string

UI should display:
- “Step 3/6: RFKill unblock failed (hard blocked)”
- optional “Details” drawer for the technical payload

Key takeaway:
The daemon call path is correct, but semantics are split between UI and daemon, DHCP isn’t actually part of hardware selection,
NM “unmanaged” isn’t enforced, and sleeps/retries are baked into core activation.
